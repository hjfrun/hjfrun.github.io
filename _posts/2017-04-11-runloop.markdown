---
layout:     post
title:      Runloop
subtitle:   
date:       2017-04-11 11:07:35
author:     hjfrun
header-img: 
catalog: false
tags:
    - iOS
    - runloop
---

> 最近在看runloop相关的资料，看到很多质量很高的博客，于是总结了下相关资料，摘录下来。



iOS里面，一个程序开始运行之后就放在那里，如果不对它进行任何操作，，这个应用就像静止了一样，不会自发的有任何动作发生，但是如果我们点击界面上的一个按钮，这个时候机会会有对应的按钮响应时间发生。给我买的感觉就像应用一直处于随时待命状态，在没人操作的时候它一直休息，在让它干活的时候，它能立刻响应。其实，这是runloop的功劳。

### 一、线程与runloop

#### 1. 线程的任务类型

有些线程的执行任务是一条直线，起点到终点；而另一些线程要干的活是一个圆，不断循环，知道通过某种方式将它终止。圆类型的如操作系统，一直运行到关机。在iOS中，圆形的线程就是通过runloop不停的循环实现的。

#### 2. 线程与runloop的关系

一直运行着的循环。runloop是为了线程而在。没有线程，它也就没有存在的必要。runloop是线程的基础架构部分，Cocoa和CoreFoundation都提供了runloop对象方便配置和管理线程的runloop。每个线程都有与之对应的runloop对象。

##### 主线程的runloop是默认启动的

iOS的应用程序里面，程序启动后会有一个main函数:

```objc
int main(int argc,char *argv[])

 {

        @autoreleasepool {

          return UIApplicationMain(argc, argv, nil, NSStringFromClass([appDelegate class]));

       }

}
```

重点是UIApplicationMain函数，这个方法会设置一个NSRunLoop对象，这就解释了为什么我们的程序可以在无人操作时候休息，需要它干活的时候又能立马响应。

对其他线程来说，runloop默认是没有启动的，如果需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。

在任何一个Cocoa程序的线程中，都可以通过

```objc
NSRunLoop *runloop = [NSRunloop currentRunLoop];
```

来获取当前线程的runloop。

#### 3. 关于runloop的几点说明

`Cocoa中的NSRunLoop类并不是线程安全的`

我们不能在一个线程中去操作另外一个线程的runloop对象，那很可能造成意想不到的结果。CoreFoundation提供的CFRunLoopRef是线程安全，而且两种runloop可以混用。

`runloop的管理并不是完全自动的`

我们仍必须设计线程代码以在适当的时候启动runloop并正确响应输入事件，

`runloop同时也负责autorelease pool的创建和释放`

在使用手动的内存管理方式的项目中，会经常用到很多自动释放的对象，如果这些对象不能够被立即释放，会造成内存急剧增大。runloop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型的变量都会释放掉。

runloop的优点

一个runloop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。

首先，runloop是一种更高明的消息处理模式，高明之处就在对消息处理过程进行了更好的抽象和封装，这样才能是我们不用处理一些很琐碎的低层次的具体的消息处理，在runloop中每个消息就被打包在input source或者timer source中了。

其次，runloop可以使线程在有工作的时候工作，没有工作的时候休息，可以大大的节省系统资源。

### 二、runloop相关知识点

#### 1. 输入事件来源

runloop接收输入事件来自两种不同的源，输入源input source和定时源timer source。两种源都是用程序的某一特定的处理例程来处理到达的时间。

需要说明的是，当创建输入源，需要将其分配给runloop中的一个或者多个模式。模式只会在特定的时间影响监听的源。大多数情况下，runloop运行在默认*模式*下，但是也可以使其运行在自定义模式。若某一个源在当前模式下不被监听，那么任何其生成的消息只在runloop运行在其关联的模式下才会被传递。

##### 输入源（input source）

传递异步事件，通常消息来自于其他线程或程序。输入源传递异步消息给相应的处理程序，并调用runUntilDate：方法来退出。

###### 基于端口的输入源

基于端口的输入源由内核自动发送。Cocoa和CoreFoundation内置支持使用端口相关的对象和函数来创建的基于端口的源。例如在Cocoa里面从来不需要直接创建输入源。只要简单的创建端口对象，并使用NSPort方法把该端口添加到runloop。端口对象会自己处理创建和配置输入源。

在Core Foundation，必须人工创建端口和它的runloop源。我们可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。

###### 自定义输入源

自定义的输入源需要人工从其他线程发送。

为了创建自定义的输入源，必须使用CoreFoundation里面的CFRunLoopSourceRef类型相关的函数来创建。可以使用回调函数来配置自定义输入源。Core Fundation会在配置源的不同地方调用回调函数，处理输入事件，在源从run loop移除的时候清理它。

除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并通知它处理数据。消息传递机制的定义取决于你，但最好不要过于复杂。

###### Cocoa上的Selector源

除了基于端口的源，Cocoa定义了自定义输入源，允许在任何线程执行selector方法。和基于端口的源不一样，执行selector请求会在目标线程上序列化，一个selector执行完后会自动从runloop里面移除。

当在其他线程上执行selector时，目标线程有一个活动的runloop。意味着线程在显式启动runloop之前是不会执行selector方法的，而是一直处于休眠状态。

##### 定时源（timer source）

定时源在预设的时间点同步方式传递消息，这些消息都会发生在特定时间或者重复的时间间隔。定时源则直接传递消息给处理例程。不会立即退出runloop。

需要注意的是，尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和runloop特定的模式相关。如果定时器所在的模式当前未被runloop见识，那么定时器将不会开始知道runloop运行在相应的模式下。类似，如果定时器在runloop处理某一事件期间开始，定时器会一直等待知道下次runloop开始相应的处理程序。如果runloop不再运行，那定时器也将永远不启动。

#### runloop观察者

源是在合适的同步或异步事件发生时触发，而runloop观察者则是在runloop本身运行的特定时候触发。可以使用runloop观察者来为处理某一个特定事件或进入休眠的线程做准备。可以将runloop观察者和以下事件关联：

* runloop入口
* runloop何时处理一个定时器
* runloop何时处理一个输入源
* runloop何时进入睡眠状态
* runloop何时被唤醒，但在唤醒之前要处理的时间
* runloop终止

和定时器类似，在创建的时候可以runloop观察者可以只用一次或循环使用。若只用一次，那么在它启动后，会把它自己从runloop里面移除，而循环的观察者不会。定义观察者并把它添加到runloop，只能使用CoreFoundation。

```objc
- (void)addObserverToCurrentRunloop

{

    // The application uses garbage collection, so noautorelease pool is needed.

    NSRunLoop*myRunLoop = [NSRunLoop currentRunLoop];

   

    // Create a run loop observer and attach it to the runloop.

    CFRunLoopObserverContext  context = {0,self, NULL,NULL, NULL};

   CFRunLoopObserverRef    observer =CFRunLoopObserverCreate(kCFAllocatorDefault,

                                                              kCFRunLoopBeforeTimers,YES, 0, &myRunLoopObserver, &context);

   

    if (observer)

    {

        CFRunLoopRef    cfLoop = [myRunLoopgetCFRunLoop];

       CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);

    }

}
```

其中，kCFRunLoopBeforeTimers表示选择监听定时器触发前处理事件，后面的YES表示循环监听。

#### runloop的事件队列

每次运行runloop，线程的runloop会自动处理之前未处理的消息，并通知相关观察者。



